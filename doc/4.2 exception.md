# 5.2 exception

本文介绍 PCR_GBA_Tool 的异常处理机制，用于任务流程控制和错误处理

代码位于：module/exception.py

---

PCR 的异常分为两类：

1. **流程控制异常**：用于正常的任务流程跳转（如任务结束、阶段完成）
2. **错误异常**：表示错误情况，需要处理或恢复

---

## TaskEnd

任务正常结束

**Raise**：
- 完成所有每日任务后，抛出 `TaskEnd` 结束任务
- 挑战次数用完，抛出 `TaskEnd` 结束挑战模块
```python
if self.is_all_missions_completed():
    logger.info("所有每日任务已完成")
    raise TaskEnd
```

**Catch**：

```python
def run(self, command):
    try:
        self.__getattribute__(command)()
        return True
    except TaskEnd:
        return True  # 任务正常结束
```

---

## ScriptEnd

脚本正常结束

**使用场景**：
- 用户手动停止脚本
- 所有计划任务执行完毕

---

## ProcessComplete

某个处理阶段结束

- 战斗中的攻击阶段结束，抛出 `ProcessComplete` 进入奖励阶段
- 多阶段任务中，完成某个阶段后跳转到下一阶段

```python
def _attack_phase(self):
    # 战斗阶段
    if self.all_enemies_defeated():
        raise ProcessComplete

def run(self):
    try:
        self._attack_phase()
    except ProcessComplete:
        self._reward_phase()  # 进入结算阶段
```

---

## GamePageUnknownError

无法识别当前游戏页面



**Raise**：
脚本启动时，检测 200 秒（10秒 × 20次），如果仍无法识别当前在哪个页面

```python
def ui_get_current_page(self, skip_first_screenshot=True):
    """获取当前所在页面

    Raises:
        GamePageUnknownError: 无法识别当前页面
    """
    timeout = Timer(10, count=20).start()
    while 1:
        if timeout.reached():
            break

        # 遍历所有已知页面
        for page in Page.iter_pages():
            if self.ui_page_appear(page=page):
                return page

        # 点击"返回主界面"按钮
        if self.appear_then_click(GO_TO_MAIN, offset=(30, 30), interval=2):
            timeout.reset()
            continue

    # 超时
    logger.warning("Unknown ui page")
    logger.critical("Please switch to a supported page before starting PCR")
    raise GamePageUnknownError
```

- 游戏在不支持的页面
- 游戏界面被其他弹窗覆盖

**Catch**：
未被捕获，会导致脚本退出

需要用户手动将游戏切换到主界面

---

## GameStuckError

游戏界面卡住超过 60 秒

- 战斗中画面卡住不动
- 加载界面卡死
- 网络延迟导致长时间无响应

**Raise**：
```python
def stuck_record_check(self):
    """检查是否卡住超过 60 秒

    Raises:
        GameStuckError: 界面卡住超过 60 秒
        GameNotRunningError: 应用已挂掉
    """
    reached = self.stuck_timer.reached()  # 60 秒超时

    if not reached:
        return False

    logger.warning("Wait too long")
    logger.warning(f"Waiting for {self.detect_record}")

    # 检查应用是否还在运行
    if self.app_is_running():
        raise GameStuckError(f"Wait too long")
    else:
        raise GameNotRunningError("Game died")
```

- 超过 60 秒没有检测到任何新的页面或按钮变化
- 应用进程仍然存在（如果进程已终止，抛出 `GameNotRunningError`）

**Catch**：

```python
except (GameStuckError, GameTooManyClickError) as e:
    logger.error(e)
    logger.warning(f"Game stuck, will be restarted in 10 seconds")
    logger.warning("If you are playing by hand, please stop the script")
    self.device.sleep(10)
    return False  # 返回 False，触发游戏重启
```

1. 等待 10 秒
2. 返回 `False` 通知调度器
3. 调度器会重启游戏并重试

---

## GameNotRunningError

游戏未运行或进程已终止

- 游戏崩溃
- 用户手动关闭游戏
- 模拟器重启

**Raise**：

```python
# 界面卡住
def stuck_record_check(self):
    if self.stuck_timer.reached():
        if self.app_is_running():
            raise GameStuckError(f"Wait too long")
        else:
            raise GameNotRunningError("Game died")

# 游戏未运行
def ui_get_current_page(self):
    @run_once
    def app_check():
        if not self.device.app_is_running():
            raise GameNotRunningError("Game not running")
```

**Catch**：

```python
except GameNotRunningError as e:
    logger.warning(e)
    logger.warning("Game not running, will restart")
    return False  # 返回 False，触发游戏重启
```

返回 `False` 通知调度器，调度器会重新启动游戏

---

## GameTooManyClickError

陷入点击循环，无法自动解决

- 脚本在两个按钮之间来回点击
- 重复点击同一个按钮但页面没有变化
- 页面导航逻辑出错

**Raise**：

```python
def click_record_check(self):
    """检查是否陷入无限点击循环

    Raises:
        GameTooManyClickError: 点击同一按钮 12 次或两按钮互点 6 次
    """
    count = collections.Counter(self.click_record).most_common(2)

    # 点击同一按钮 12 次
    if count and count[0][1] >= 12:
        logger.warning(f"Too many click for a button: {count[0][0]}")
        raise GameTooManyClickError(f"Too many click for a button: {count[0][0]}")

    # 两按钮互相点击各 6 次
    if len(count) >= 2 and count[0][1] >= 6 and count[1][1] >= 6:
        logger.warning(f"Too many click between 2 buttons: {count[0][0]}, {count[1][0]}")
        raise GameTooManyClickError(
            f"Too many click between 2 buttons: {count[0][0]}, {count[1][0]}"
        )
```

- 最近 15 次点击记录中，同一按钮被点击 12 次
- 或者两个按钮互相点击各 6 次

**Catch**：

```python
except (GameStuckError, GameTooManyClickError) as e:
    logger.error(e)
    self.device.sleep(10)
    return False  # 触发游戏重启
```

1. 等待 10 秒
2. 返回 `False`，触发游戏重启
3. 重启后清空点击记录，重新尝试

---

## EmulatorNotRunningError

模拟器未运行

- 脚本启动时，检测不到任何可用设备
- 配置中指定的设备序列号不存在

**Raise**：
```python
# 没有任何可用设备
def select_device(self):
    available = self.list_device()
    if len(available) == 0:
        raise EmulatorNotRunningError("No available devices")

# 指定的设备不存在
if not any(d.serial == self.serial for d in available):
    logger.error(f"Device {self.serial} not found")
    raise EmulatorNotRunningError(f"Device {self.serial} not found")

# 设备无法访问
if not self.adb.devices_check():
    raise EmulatorNotRunningError(f"Device {self.serial} not accessible")
```

**Catch**：
未被捕获，会导致脚本退出

1. 启动模拟器
2. 检查 ADB 连接
3. 修正配置文件中的设备序列号

---

## RequestHumanTakeover

请求人工接管，脚本无法自动处理

这是**最严重**的异常，表示脚本遇到了无法自动解决的问题，需要用户介入

### ADB 重试全部失败

```python
def retry(func):
    """重试装饰器"""
    @wraps(func)
    def retry_wrapper(self, *args, **kwargs):
        for i in range(RETRY_TRIES):  # 重试 5 次
            try:
                return func(self, *args, **kwargs)
            except RequestHumanTakeover:
                break  # 如果捕获到 RequestHumanTakeover，停止重试
            except Exception as e:
                pass

        logger.critical(f"Retry {func.__name__}() failed")
        raise RequestHumanTakeover
```

ADB 操作（如截图、点击）重试 5 次都失败后，抛出 `RequestHumanTakeover`

---

### 多个设备无法自动选择

```python
def select_device(self):
    available = self.list_device()

    if self.serial == "auto":
        if len(available) > 2:  # 超过 2 个设备
            logger.error(f"Multiple devices found ({len(available)})")
            logger.error("AUTO mode cannot decide which device to use")
            logger.error("Please specify device serial in config file (Emulator.Serial)")
            raise RequestHumanTakeover("Please specify device serial in config")
```

连接了多个设备（超过 2 个），配置文件中未指定使用哪个，脚本无法自动选择

需要用户在配置文件中设置 `Emulator.Serial` 为具体的设备序列号

---

### 游戏包未安装

```python
def detect_package(self):
    """检测游戏包名"""
    # ... 遍历已知的游戏包名 ...

    # 未找到任何已知的游戏包
    logger.error("PCR package not found")
    possible_reasons(
        "游戏未安装",
        "包名不在支持列表中",
        "模拟器中未安装公主连结"
    )
    raise RequestHumanTakeover("PCR package not installed")
```

在模拟器中找不到公主连结游戏的安装包

在模拟器中安装公主连结游戏

---

### 设备初始化失败

```python
def __init__(self, *args, **kwargs):
    try:
        super().__init__(*args, **kwargs)
        # 初始化
    except Exception as e:
        logger.exception(e)
        raise RequestHumanTakeover
```

---

**Catch**：

```python
except RequestHumanTakeover:
    logger.critical("Request human takeover")
    exit(1)  # 直接退出程序
```

直接退出程序，用户需要：
1. 查看日志中的错误信息
2. 手动解决问题（启动模拟器、安装游戏、修正配置等）

---

## ScriptError

脚本错误，通常是开发者的失误

- 未知的设备方法
- 未找到任务处理器
- 配置错误

**Raise**：

```python
# 未知的截图方法
def load_screenshot(self, screenshot):
    if method in ['ADB', 'uiautomator2', 'aScreenCap']:
        # 处理截图
        pass
    else:
        raise ScriptError(f"Unknown method to load screenshots: {method}")

# 无效的设备方向
if orientation not in [0, 1, 2, 3]:
    raise ScriptError(f"Invalid device orientation: {orientation}")
```

**Catch**：
未被明确捕获，会导致脚本退出

需要开发者检查代码逻辑

---

## ResourceExhausted

资源耗尽的基类，所有资源相关异常都继承自此类

---