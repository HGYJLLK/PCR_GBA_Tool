# 3.1 image_recognition

本文介绍 PCR_GBA_Tool 的图像识别功能

## Button：位置相对固定的按钮

代码位于：module/base/button.py

Button 是图像识别的核心类，代表游戏界面中的按钮或可交互元素

### 定义

```python
from module.base.button import Button

EXAMPLE_BUTTON = Button(
    area=(600, 400, 680, 480),      # 检测区域 (x1, y1, x2, y2)
    color=(100, 150, 255),           # 期望颜色 (r, g, b)
    button=(600, 400, 680, 480),     # 点击区域 (x1, y1, x2, y2)
    file='./assets/daily/EXAMPLE_BUTTON.png',
    name='EXAMPLE_BUTTON'            # 可选
)
```

| 属性     | 类型  | 说明                                     |
| -------- | ----- | ---------------------------------------- |
| `area`   | tuple | 检测区域                                 |
| `color`  | tuple | 期望的平均 RGB 颜色                      |
| `button` | tuple | 点击区域，通常与 `area` 相同，也可以不同 |
| `file`   | str   | 模板图片路径，支持 `.png` 和 `.gif`      |
| `name`   | str   | 按钮名称，用于日志输出                   |

### appear_on(image, threshold=10)

通过颜色匹配检查按钮是否出现

```python
if BUTTON.appear_on(self.device.image, threshold=10):
    logger.info("Button appeared")
```

### match(image, offset=30, similarity=0.85)

通过模板匹配检测按钮，用于位置可能不固定的按钮

```python
if BUTTON.match(self.device.image, offset=30, similarity=0.85):
    logger.info("Button matched")
```

## 添加 Button

推荐使用 `create_button.py` 快速创建按钮，无需 PS 处理图片

python dev_tools/create_button.py

```bash
┌─────────────────────────────────────┐
│ 运行脚本自动截图                     │
│    python dev_tools/create_button.py │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 在浏览器中框选按钮区域               │
│    • 拖动鼠标框选                    │
│    • 输入按钮名称                    │
│    • 复制生成的 JSON                 │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 粘贴 JSON 到控制台                   │
│    自动提取并保存到 assets/train/    │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│ 重复 2-3 创建更多按钮                │
│    直接回车退出并保存                │
└─────────────────────────────────────┘
```

脚本会提示你确认游戏界面，按 Enter 后自动截图并在浏览器中打开选择工具

```bash
==========================================================
批量按钮创建工具
==========================================================
------------------------------------------------
Step 1: 截图
------------------------------------------------
请确保游戏界面显示你要提取的按钮,然后按 Enter...
```

1. **框选区域**：在网页中拖动鼠标框选按钮区域
2. **输入名称**：在输入框输入按钮名称（如 `DAILY_BUTTON`）
3. **复制 JSON**：点击"复制 JSON"按钮

```json
{ "name": "DAILY_BUTTON", "coords": [600, 400, 680, 480] }
```

回到命令行，粘贴 JSON 并按 Enter：

```bash
------------------------------------------------
等待输入
------------------------------------------------
请从网页复制JSON数据并粘贴（直接回车退出):
{"name": "DAILY_BUTTON", "coords": [600, 400, 680, 480]}
✓ 按钮名称: DAILY_BUTTON
✓ 坐标: (600, 400, 680, 480)
------------------------------------------------
Step 4: 提取并保存按钮
------------------------------------------------
✓ 已保存按钮图片: /path/to/assets/train/DAILY_BUTTON.png
  尺寸: 80 × 80
生成的 Button 定义:
  DAILY_BUTTON = Button(area=(600, 400, 680, 480), color=(100, 150, 255), button=(600, 400, 680, 480), file="./assets/train/DAILY_BUTTON.png")
```

如果需要创建多个按钮，重复 Step 2-3，脚本会自动收集所有按钮定义

完成后直接按 Enter（空输入）退出：

```bash
==========================================================
写入 assets.py
==========================================================
✓ 已写入 3 个按钮到 ./module/train/assets.py
  • DAILY_BUTTON
  • BATTLE_START_BUTTON
  • REWARD_BUTTON
==========================================================
完成!
==========================================================
✓ 共创建 3 个按钮
✓ 临时文件已清理
```

**生成的图片**：

```bash
┌──────────────────────┐
│████████████████████│  ← 黑色区域（不识别）
│████  [确认]  ████│  ← 白色/彩色区域（识别区域）
│████████████████████│
└──────────────────────┘
```

**生成的代码**：

```python
# module/train/assets.py
from module.base.button import Button
from module.base.template import Template

# This file was automatically generated by dev_tools/button_extract.py.
# Don't modify it manually.

DAILY_BUTTON = Button(area=(600, 400, 680, 480), color=(100, 150, 255), button=(600, 400, 680, 480), file="./assets/train/DAILY_BUTTON.png")
BATTLE_START_BUTTON = Button(area=(550, 600, 730, 680), color=(255, 200, 100), button=(550, 600, 730, 680), file="./assets/train/BATTLE_START_BUTTON.png")
```

## 使用 Button

假设开发一个"每日任务"模块：

```python
# module/daily/daily.py
from module.base.base import ModuleBase
from module.daily.assets import *

class DailyTask(ModuleBase):
    """每日任务模块"""

    def run(self):
        """运行每日任务"""
        # 截图
        self.device.screenshot()

        # 方法1：先检测，再点击
        # 检测按钮是否出现
        if self.appear(DAILY_TASK_BUTTON):
            # 点击按钮
            self.device.click(DAILY_TASK_BUTTON)
            return True
        return False

        # 方法2：出现并点击
        self.appear_then_click(DAILY_TASK_BUTTON, interval=2)
```

**重点说明**：

- **必须继承 `ModuleBase`**：它提供了 `appear()`、`device` 等核心方法
- **从 assets 导入按钮**：`DAILY_TASK_BUTTON` 是在 `assets.py` 中定义的
- **先截图再检测**：`self.device.screenshot()` 必须在 `self.appear()` 之前调用
- `interval=2`：点击后 2 秒内不再响应，防止连点

## self.appear(button, offset=0, interval=0, similarity=0.85, threshold=10)

判断 button 是否出现在画面中

**参数说明**：

- **offset**：按钮的偏移量。
  - `offset=0` 或 `False`：使用平均颜色识别（`Button.appear_on()`），速度快
  - `offset=30`：使用模板匹配识别（`Button.match()`），在按钮周围 30 像素范围内搜索
  - 假设 `button.area=(100, 200, 300, 400)`，`offset=30`，那么将在 `(70, 170, 330, 430)` 的区域内搜索按钮

- **interval**：按钮出现间隔。按钮出现后的若干秒内，对这个按钮的识别返回 False。一般设置 2 或 3 秒，能避免连击

- **similarity**：模板匹配相似度阈值（0~1），默认 0.85

- **threshold**：颜色匹配阈值（0~255），默认 10，值越小表示颜色越相似

## self.appear_then_click(button, screenshot=False, genre="items", offset=0, interval=0, similarity=0.85, threshold=30)

判断 button 是否出现在画面中，出现了就点击

本质上是：

```python
if self.appear(button):
    self.device.click(button)
```

**特殊特性**：在设置了 offset 的情况下，即便游戏内的按钮相对 asset 图片有所移动，也能点击被移动后的按钮。原理是 `Button.match()` 在匹配成功时会设置 `_button_offset`，而 `self.device.click()` 也会使用 `_button_offset`。

## self.image_crop(button, copy=True)

从当前截图中裁剪区域

**参数说明**：

- **button**：Button 对象或区域元组 `(x1, y1, x2, y2)`
- **copy**：是否复制图像，默认 True

**返回值**：裁剪后的图像（np.ndarray）

```python
# 使用 Button 对象
card_image = self.image_crop(CARD_BUTTON)

# 使用区域元组
card_image = self.image_crop((100, 100, 200, 200))
```

## self.match_template_color(button, offset=(20, 20), interval=0, similarity=0.85, threshold=30)

模板匹配 + 颜色验证，先进行模板匹配，匹配成功后再进行颜色验证

```python
if self.match_template_color(BUTTON, offset=(20, 20), similarity=0.85, threshold=30):
    logger.info("Button matched with both template and color")
```

## 等待按钮出现

```python
from module.base.timer import Timer

def wait_for_button(self):
    """等待按钮出现（最多等 10 秒）"""
    timeout = Timer(10).start()

    while not timeout.reached():
        self.device.screenshot()
        if self.appear(DAILY_BUTTON):
            logger.info("Button appeared!")
            return True


    logger.warning("Button not found after 10s")
    return False
```

---

## Template：位置不固定的模板匹配

### 什么是 Template

代码位于：module/base/template.py

Template 用于识别**位置不固定**的元素，比如列表中的角色头像、敌人位置等。

### 添加 Template

直接裁剪出要识别的**局部图像**：

```bash
assets/
  └── train/
      └── TEMPLATE_ENEMY.png   # 必须以 TEMPLATE_ 开头
```

**注意**：

- 文件名**必须**以 `TEMPLATE_` 开头
- 直接裁剪，**不需要**像 Button 那样填充黑色

运行 button_extract

```bash
python -m dev_tools.button_extract
```

生成的代码：

```python
# module/train/assets.py
from module.base.template import Template

TEMPLATE_ENEMY = Template(file='./assets/train/TEMPLATE_ENEMY.png')
```

### match(image, scaling=1.0, similarity=0.85)

全屏搜索匹配模板

### match_result(image, name=None)

全屏搜索匹配模板，返回相似度和位置（Button 对象）

### match_multi(image, scaling=1.0, similarity=0.85, threshold=3, name=None)

匹配目标出现的所有位置，返回所有匹配位置的 Button 列表。

### 使用 Template

#### 检测是否存在

```python
from module.base.base import ModuleBase
from module.train.assets import TEMPLATE_ENEMY

class Combat(ModuleBase):
    def has_enemy(self):
        """检测屏幕上是否有敌人"""
        self.device.screenshot()

        # Template 的 match() 方法在全屏搜索
        return TEMPLATE_ENEMY.match(self.device.image, similarity=0.85)
```

**参数说明**：

- `similarity=0.85`：相似度阈值（0~1），越高越严格

#### 获取位置并点击

```python
def click_enemy(self):
    """找到敌人并点击"""
    self.device.screenshot()

    # match_result() 返回相似度和位置
    sim, button = TEMPLATE_ENEMY.match_result(self.device.image)

    if sim > 0.85:
        logger.info(f"Found enemy at {button.area}, similarity={sim:.2f}")
        self.device.click(button)  # button 是可点击的 Button 对象
        return True
    return False
```

#### 找到所有匹配位置

```python
def click_all_enemies(self):
    """点击屏幕上所有敌人"""
    self.device.screenshot()

    # match_multi() 返回所有匹配的 Button 列表
    enemies = TEMPLATE_ENEMY.match_multi(
        self.device.image,
        similarity=0.85,
        threshold=3  # 聚类阈值，合并相邻的匹配点
    )

    logger.info(f"Found {len(enemies)} enemies")
    for enemy in enemies:
        self.device.click(enemy)
        self.device.sleep(0.3)
```

## Mask：区域过滤

### 什么是 Mask

Mask（掩码）用于**限定搜索区域**，避免误判，通常与 template 结合使用

角色列表中有"小明"，队伍中也有"小明"，如果使用 Template 会同时匹配到两个，通过 Mask 可以避免误判，只在列表区域搜索

### 添加 Mask

获取游戏截图（同 Button）：

```bash
python dev_tools/droidcast_raw.py
```

使用 PS 处理：

1. 在 Photoshop 中打开截图（1280x720）
2. 新建一个空白图层
3. 用矩形选框工具框选**需要搜索的区域**（如角色列表区域）
4. 填充白色（Shift+F5 → 白色 → 100%）
5. 反选（Ctrl+Shift+I）
6. 填充黑色（Shift+F5 → 黑色 → 100%）
7. 保存为 PNG 格式到 `assets/{module}/` 目录
   > mask 遮罩图片没有强制要求文件名格式，强制要求的只有 template

**处理后的 Mask 示例**：

```bash
┌──────────────────────┐
│████████████████████│  ← 黑色区域（忽略）
│████  ░░░░░░  ████│  ← 白色区域（搜索区域）
│████  ░░░░░░  ████│
│████████████████████│
└──────────────────────┘
```

**使用 Mask**：

```python
from module.base.mask import Mask

MASK_LIST = Mask(file='./assets/character/MASK_LIST.png')

# 应用掩码
masked_image = MASK_LIST.apply(self.device.image)

# 在掩码后的图像中搜索
sim, button = TEMPLATE_CHAR.match_result(masked_image)
```

---

## 常见问题

### Q1: Button 和 Template 如何选择？

```bash
位置是否固定？
├─ 是 → Button
│   └─ 颜色是否鲜明且稳定？
│       ├─ 是 → offset=0（颜色匹配）
│       └─ 否 → offset=20（模板匹配）
└─ 否 → Template
    └─ 需要找所有位置？
        ├─ 是 → match_multi()
        └─ 否 → match() 或 match_result()
```

### Q2: 为什么 `self.appear()` 总返回 False？

1. 是否调用了 `self.device.screenshot()`？
2. Button 是否正确导入？
3. 截图分辨率是否是 1280x720？
4. 尝试降低 `similarity` 或增大 `threshold`

### Q3: 如何调试识别问题？

```python
# 保存截图查看
self.device.screenshot()
self.device.save_screenshot(genre='debug')

# 打印匹配相似度
if hasattr(button, 'match_result'):
    sim, pos = button.match_result(self.device.image)
    logger.info(f"Similarity: {sim:.2f}, Position: {pos.area}")
```
