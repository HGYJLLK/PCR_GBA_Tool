# 配置系统

本文档详细介绍 PCR_GBA_Tool 的配置系统设计。

## 概述

配置系统采用三层架构：

```
YAML 定义层 (开发者编写)
       │
       ▼
自动生成层 (config_updater.py)
       │
       ├── config_generated.py (Python 类，提供代码补全)
       │
       └── template.json (配置模板)
              │
              ▼
用户配置层 (*.json 文件)
```

## 配置文件结构

### JSON 配置格式

```json
{
  "Pcr": {
    "Scheduler": {
      "Enable": true,
      "Command": "Pcr",
      "NextRun": "2020-01-01 00:00:00"
    },
    "Emulator": {
      "Serial": "auto",
      "PackageName": "com.bilibili.priconne",
      "ScreenshotMethod": "DroidCast_raw",
      "ControlMethod": "MaaTouch"
    },
    "Optimization": {
      "ScreenshotInterval": 0.3,
      "ClickInterval": 0.1
    }
  },
  "PcrDaily": {
    "Scheduler": {
      "Enable": true,
      "Command": "PcrDaily",
      "NextRun": "2020-01-01 05:00:00"
    }
  }
}
```

## 核心类

### PriconneConfig

主配置类，继承自多个基类：

```python
class PriconneConfig(ConfigUpdater, GeneratedConfig, ConfigWatcher):
    """公主连结配置类"""
```

#### 初始化流程

```python
def __init__(self, config_name="template", task=None):
    self.config_name = config_name
    self.data = {}        # 完整的 JSON 数据
    self.modified = {}    # 暂存区，记录修改
    self.bound = {}       # 地址簿，属性名 -> JSON 路径
    self.auto_update = True
    self.init_task(task)  # 加载并绑定配置
```

#### 核心方法

| 方法 | 说明 |
|------|------|
| `load()` | 从 JSON 文件加载配置到 `self.data` |
| `bind(func)` | 绑定任务配置，创建属性快捷方式 |
| `save()` | 保存修改到 JSON 文件 |
| `update()` | 重新加载并保存配置 |

### 属性绑定机制 (bind)

`bind()` 方法是配置系统的核心，它完成两项工作：

1. **创建属性快捷方式**: `config.Emulator_Serial`
2. **建立地址簿**: 属性名 -> JSON 路径的映射

```python
def bind(self, func, func_list=None):
    # 配置优先级列表: ["Pcr", <task>]
    if func_list is None:
        func_list = []
    if func not in func_list:
        func_list.insert(0, func)
    if "Pcr" not in func_list:
        func_list.insert(0, "Pcr")

    visited = set()
    self.bound.clear()

    for func in func_list:
        func_data = self.data.get(func, {})
        for group, group_data in func_data.items():
            if isinstance(group_data, dict):
                for arg, value in group_data.items():
                    path = f"{group}.{arg}"
                    if path in visited:
                        continue
                    # 转换路径为属性名
                    arg_name = path_to_arg(path)  # "Emulator.Serial" -> "Emulator_Serial"
                    # 创建属性
                    super().__setattr__(arg_name, value)
                    # 记录地址簿
                    self.bound[arg_name] = f"{func}.{path}"
                    visited.add(path)
```

#### 绑定示例

假设 JSON 数据：

```json
{
  "Pcr": {
    "Emulator": {
      "Serial": "127.0.0.1:16384",
      "ScreenshotMethod": "DroidCast_raw"
    }
  }
}
```

绑定后：

```python
# 属性快捷方式
config.Emulator_Serial = "127.0.0.1:16384"
config.Emulator_ScreenshotMethod = "DroidCast_raw"

# 地址簿
config.bound = {
    "Emulator_Serial": "Pcr.Emulator.Serial",
    "Emulator_ScreenshotMethod": "Pcr.Emulator.ScreenshotMethod"
}
```

### 自动保存机制

通过重写 `__setattr__` 实现自动保存：

```python
def __setattr__(self, key, value):
    if key in self.bound:
        path = self.bound[key]      # 查找 JSON 路径
        self.modified[path] = value  # 记录修改
        if self.auto_update:
            self.update()            # 自动更新
    else:
        super().__setattr__(key, value)
```

#### 工作流程

```
1. 代码修改配置
   config.Emulator_Serial = "new_value"
           │
           ▼
2. __setattr__ 拦截
   检测 "Emulator_Serial" 在 bound 中
           │
           ▼
3. 查询地址簿
   bound["Emulator_Serial"] = "Pcr.Emulator.Serial"
           │
           ▼
4. 记录修改
   modified["Pcr.Emulator.Serial"] = "new_value"
           │
           ▼
5. 自动更新
   update() -> load() + save()
           │
           ▼
6. 写入 JSON 文件
```

## 配置生成器

### ConfigUpdater

负责从 YAML 生成配置：

```bash
python -m module.config.config_updater
```

#### 输入文件

| 文件 | 说明 |
|------|------|
| `argument.yaml` | 定义所有可能的配置参数 |
| `task.yaml` | 定义任务与参数的对应关系 |
| `default.yaml` | 定义参数默认值 |
| `override.yaml` | 定义不可修改的锁定值 |

#### 输出文件

| 文件 | 说明 |
|------|------|
| `config_generated.py` | Python 配置类，提供 IDE 代码补全 |
| `template.json` | 配置模板文件 |

### GeneratedConfig

自动生成的配置类，定义所有配置属性：

```python
class GeneratedConfig:
    # 模拟器配置
    Emulator_Serial: str = "auto"
    Emulator_PackageName: str = "com.bilibili.priconne"
    Emulator_ScreenshotMethod: str = "DroidCast_raw"
    Emulator_ControlMethod: str = "MaaTouch"

    # 优化配置
    Optimization_ScreenshotInterval: float = 0.3
    Optimization_ClickInterval: float = 0.1
    # ...
```

**注意**: 永远不要手动编辑 `config_generated.py`，它是自动生成的。

## Function 类

用于任务调度的封装类：

```python
class Function:
    def __init__(self, data):
        self.enable = deep_get(data, keys="Scheduler.Enable", default=False)
        self.command = deep_get(data, keys="Scheduler.Command", default="Unknown")
        self.next_run = deep_get(data, keys="Scheduler.NextRun", default=DEFAULT_TIME)

    def __str__(self):
        enable = "Enable" if self.enable else "Disable"
        return f"{self.command} ({enable}, {str(self.next_run)})"
```

### 用途

调度器读取 JSON 中的任务配置，创建 Function 对象：

```python
# JSON 配置
{
  "PcrDaily": {
    "Scheduler": {
      "Enable": true,
      "Command": "PcrDaily",
      "NextRun": "2024-01-01 05:00:00"
    }
  }
}

# 创建 Function
func = Function(data["PcrDaily"])
# func.enable = True
# func.command = "PcrDaily"
# func.next_run = "2024-01-01 05:00:00"
```

## 工具函数

### deep_get / deep_set

嵌套字典的安全访问：

```python
from module.config.deep import deep_get, deep_set

data = {"Pcr": {"Emulator": {"Serial": "auto"}}}

# 获取
value = deep_get(data, "Pcr.Emulator.Serial")  # "auto"
value = deep_get(data, "Pcr.Missing.Key", default="default")  # "default"

# 设置
deep_set(data, "Pcr.Emulator.Serial", "127.0.0.1:16384")
```

### path_to_arg

路径转换为属性名：

```python
from module.config.utils import path_to_arg

path_to_arg("Emulator.Serial")  # "Emulator_Serial"
path_to_arg("GameSettings.Language")  # "GameSettings_Language"
```

## 配置优先级

当存在多个任务配置时，遵循优先级顺序：

```
1. "Pcr" (基础配置，最先加载)
2. 当前任务配置 (如 "PcrDaily")
3. 其他指定配置

先加载的值优先，后加载的相同路径会被跳过
```

示例：

```json
{
  "Pcr": {
    "Emulator": {
      "ScreenshotMethod": "ADB"
    }
  },
  "PcrDaily": {
    "Emulator": {
      "ScreenshotMethod": "DroidCast_raw"
    }
  }
}
```

如果当前任务是 "PcrDaily"：
- `func_list = ["Pcr", "PcrDaily"]`
- 先绑定 "Pcr"，`Emulator_ScreenshotMethod = "ADB"`
- 再绑定 "PcrDaily"，但路径已访问过，跳过

最终 `config.Emulator_ScreenshotMethod = "ADB"`

## 使用示例

### 读取配置

```python
from module.config.config import PriconneConfig

config = PriconneConfig("cwj", task="Pcr")

# 通过属性访问
serial = config.Emulator_Serial
method = config.Emulator_ScreenshotMethod
```

### 修改配置

```python
# 修改会自动保存
config.Emulator_Serial = "127.0.0.1:16385"

# 批量修改时禁用自动更新
config.auto_update = False
config.Emulator_Serial = "new_serial"
config.Emulator_PackageName = "new_package"
config.auto_update = True
config.update()  # 手动更新
```

### 跨任务访问

```python
# 直接访问原始数据
value = deep_get(config.data, "PcrDaily.Scheduler.Enable")

# 修改其他任务配置
config.modified["PcrDaily.Scheduler.NextRun"] = "2024-01-02 05:00:00"
config.save()
```
