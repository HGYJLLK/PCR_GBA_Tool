#!/usr/bin/env python3
"""
配置更新器和生成器
"""

import re
from copy import deepcopy
from datetime import datetime
from module.base.decorator import cached_property

from module.base.timer import timer
from module.config.deep import deep_default, deep_get, deep_iter, deep_pop, deep_set
from module.config.utils import *

CONFIG_IMPORT = '''
import datetime

# This file was automatically generated by module/config/config_updater.py.
# Don't modify it manually.


class GeneratedConfig:
    """
    Auto generated configuration
    """
'''.strip().split(
    "\n"
)


class ConfigGenerator:
    @cached_property
    def argument(self):
        """
        Load argument.yaml, and standardise its structure.

        <group>:
            <argument>:
                type: checkbox|select|textarea|input
                value:
                option (Optional): Options, if argument has any options.
                validate (Optional): datetime
        """
        data = {}
        raw = read_file(filepath_argument("argument"))
        for path, value in deep_iter(raw, depth=2):
            arg = {
                "type": "input",
                "value": "",
                # option
            }
            if not isinstance(value, dict):
                value = {"value": value}
            arg["type"] = data_to_type(value, arg=path[1])
            if isinstance(value["value"], datetime):
                arg["type"] = "datetime"
                arg["validate"] = "datetime"
            # Manual definition has the highest priority
            arg.update(value)
            deep_set(data, keys=path, value=arg)

        # Define storage group
        arg = {
            "type": "storage",
            "value": {},
            "valuetype": "ignore",
            "display": "disabled",
        }
        deep_set(data, keys=["Storage", "Storage"], value=arg)
        return data

    @cached_property
    def task(self):
        """
        <task>:
            - <group>
            - <group>
        """
        raw = read_file(filepath_argument("task"))
        # Convert list format to dict format
        data = {}
        for task, groups in raw.items():
            if isinstance(groups, list):
                data[task] = groups
            else:
                data[task] = []
        return data

    @cached_property
    def default(self):
        """
        <task>:
            <group>:
                <argument>: value
        """
        return read_file(filepath_argument("default"))

    @cached_property
    def override(self):
        """
        <task>:
            <group>:
                <argument>: value
        """
        return read_file(filepath_argument("override"))

    @cached_property
    @timer
    def args(self):
        """
        Merge definitions into standardised json.

            task.yaml ---+
        argument.yaml ---+-----> args.json
        override.yaml ---+
         default.yaml ---+

        """
        # Construct args
        data = {}
        for task, groups in self.task.items():
            # Add storage to all task
            if isinstance(groups, list):
                groups = groups.copy()
                groups.append("Storage")
            else:
                groups = ["Storage"]

            for group in groups:
                if group not in self.argument:
                    print(f"`{task}.{group}` is not related to any argument group")
                    continue
                deep_set(data, keys=[task, group], value=deepcopy(self.argument[group]))

        def check_override(path, value):
            # Check existence
            old = deep_get(data, keys=path, default=None)
            if old is None:
                print(f'`{".".join(path)}` is not a existing argument')
                return False
            # Check type
            # But allow `Interval` to be different
            old_value = old.get("value", None) if isinstance(old, dict) else old
            value = old.get("value", None) if isinstance(value, dict) else value
            if (
                type(value) != type(old_value)
                and old_value is not None
                and path[2] not in ["SuccessInterval", "FailureInterval"]
            ):
                print(
                    f'`{value}` ({type(value)}) and `{".".join(path)}` ({type(old_value)}) are in different types'
                )
                return False
            # Check option
            if isinstance(old, dict) and "option" in old:
                if value not in old["option"]:
                    print(f'`{value}` is not an option of argument `{".".join(path)}`')
                    return False
            return True

        # Set defaults
        for p, v in deep_iter(self.default, depth=3):
            if not check_override(p, v):
                continue
            deep_set(data, keys=p + ["value"], value=v)

        # Override non-modifiable arguments
        for p, v in deep_iter(self.override, depth=3):
            if not check_override(p, v):
                continue
            if isinstance(v, dict):
                typ = v.get("type")
                if typ == "state":
                    pass
                elif typ == "lock":
                    pass
                elif deep_get(v, keys="value") is not None:
                    deep_default(v, keys="display", value="hide")
                for arg_k, arg_v in v.items():
                    deep_set(data, keys=p + [arg_k], value=arg_v)
            else:
                deep_set(data, keys=p + ["value"], value=v)
                deep_set(data, keys=p + ["display"], value="hide")

        # Set command for each task
        for task, groups in self.task.items():
            if deep_get(data, keys=f"{task}.Scheduler.Command"):
                deep_set(data, keys=f"{task}.Scheduler.Command.value", value=task)
                deep_set(data, keys=f"{task}.Scheduler.Command.display", value="hide")

        return data

    @timer
    def generate_code(self):
        """
        Generate python code.

        args.json ---> config_generated.py

        """
        visited_group = set()
        visited_path = set()
        lines = CONFIG_IMPORT
        for path, data in deep_iter(self.argument, depth=2):
            group, arg = path
            if group not in visited_group:
                lines.append("")
                lines.append(f"    # Group `{group}`")
                visited_group.add(group)

            option = ""
            if "option" in data and data["option"]:
                option = "  # " + ", ".join([str(opt) for opt in data["option"]])
            path = ".".join(path)
            lines.append(
                f'    {path_to_arg(path)} = {repr(parse_value(data["value"], data=data))}{option}'
            )
            visited_path.add(path)

        with open(filepath_code(), "w", encoding="utf-8", newline="") as f:
            for text in lines:
                f.write(text + "\n")

    @timer
    def generate(self):
        """
        Generate all config files
        """
        _ = self.args
        write_file(filepath_args(), self.args)
        self.generate_code()
        print("Config generation completed")


class ConfigUpdater:
    """
    Configuration file updater
    """

    @cached_property
    def args(self):
        return read_file(filepath_args())

    def config_update(self, old, is_template=False):
        """
        Args:
            old (dict):
            is_template (bool):

        Returns:
            dict:
        """
        new = {}

        # self.args -> (args.json)
        for keys, data in deep_iter(self.args, depth=3):
            value = deep_get(old, keys=keys, default=data["value"])
            typ = data["type"]
            display = data.get("display")
            # 如果值是空的，或者被锁定了
            if (
                is_template
                or value is None
                or value == ""
                or typ in ["lock", "state"]
                or (display == "hide" and typ != "stored")
            ):
                # 使用args.json中的默认值
                value = data["value"]
            value = parse_value(value, data=data)
            deep_set(new, keys=keys, value=value)

        return new

    def read_file(self, config_name, is_template=False):
        """
        Read and update config file.

        Args:
            config_name (str): ./config/{file}.json
            is_template (bool):

        Returns:
            dict:
        """
        old = read_file(filepath_config(config_name))
        new = self.config_update(old, is_template=is_template)
        return new

    @staticmethod
    def write_file(config_name, data):
        """
        Write config file.

        Args:
            config_name (str): ./config/{file}.json
            data (dict):
        """
        write_file(filepath_config(config_name), data)

    @timer
    def update_file(self, config_name, is_template=False):
        """
        Read, update and write config file.

        Args:
            config_name (str): ./config/{file}.json
            is_template (bool):

        Returns:
            dict:
        """
        data = self.read_file(config_name, is_template=is_template)
        self.write_file(config_name, data)
        return data


if __name__ == "__main__":
    """
    Process the whole config generation.

             argument.yaml -+
                 task.yaml -+-> args.json ---> config_generated.py
             override.yaml -+       |
              default.yaml -+       |
                                    |
    (old)    template.json ---------+========> template.json
    """
    # Ensure running in PCR root folder
    import os

    os.chdir(os.path.join(os.path.dirname(__file__), "../../"))

    ConfigGenerator().generate()
    ConfigUpdater().update_file("template", is_template=True)
